#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include <graphicslib.hpp>
#include <utils.hpp>
#include <matrixlib.hpp>
#include <shader.hpp>
#include <model.hpp>
#include <camera.hpp>

namespace graphicslib {

    void mouseCallback(GLFWwindow* window, double xpos, double ypos);
    void scrollCallback(GLFWwindow* window, double xoffset, double yoffset);
    // camera
    Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));
    float lastX;
    float lastY;
    float firstMouse = true;

    //initialize glfw stuff
    Window::Window(int windowWidth, int windowHeight){
        //listen for errors generated by glfw
        glfwSetErrorCallback(glfwErrorCallback);

        //initialize glfw
        glfwInit();

        //set some window options
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE); //make window resizable
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); //compatibility to mac os users

        mWindowWidth = windowWidth;
        mWindowHeight = windowHeight;
        mWindow = NULL;
        mCoreProgram = 0;


        lastX = windowWidth/2.0f;
        lastY = windowHeight/2.0f;

        mOrthogonalProjection = true;
        mPReleased = true;

        // timing
        mDeltaTime = 0.0f;
        mLastFrame = 0.0f;
    }

    //destroy everything
    Window::~Window(){
        //destroy window
        if(mWindow){
            glfwDestroyWindow(mWindow);
        }
        //delete program
        if(mCoreProgram){
            glDeleteProgram(mCoreProgram);
        }
        glfwTerminate();
    }


    //create the window, load glad, load shaders
    void Window::createWindow() {
        //create window
        mWindow = glfwCreateWindow(mWindowWidth, mWindowHeight, "Camera View", NULL, NULL);

        if(mWindow == NULL) {
            std::cerr << "Failed to create GLFW window" << std::endl;
            this->~Window();
            return;
        }

        //make context current
        glfwMakeContextCurrent(mWindow); //IMPORTANT!!

        //set callback function to call when resize
        glfwSetFramebufferSizeCallback(mWindow, framebufferResizeCallback);
        glfwSetCursorPosCallback(mWindow, mouseCallback);
        glfwSetScrollCallback(mWindow, scrollCallback);

        // tell GLFW to capture our mouse
        glfwSetInputMode(mWindow, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

        //enable vsync
        glfwSwapInterval(1);

        //glad: load all OpenGL function pointers
        if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){
            std::cerr << "Failed to initialize GLAD" << std::endl;
            this->~Window();
            return;
        }

        //opengl options
        //make possible using 3d
        glEnable(GL_DEPTH_TEST);

    }


    void Window::run(char *filepath){

        // build and compile shaders
        // -------------------------
        Shader shader("src/model.vs", "src/model.fs");

        // load models
        // -----------
        Model model(filepath);

        // calculate the bounding box of the model
        model.calcBoundingBox();

        // size of the biggest dimension of the model
        float size = model.biggestDimensionSize();

        // initial position
        modelCoord.position[0] = -(model.boundingBox.x.center);
        modelCoord.position[1] = -(model.boundingBox.y.center);
        modelCoord.position[2] = -(model.boundingBox.z.center);

        // initial rotation
        modelCoord.rotation[0] = 0.f;
        modelCoord.rotation[1] = 0.f;
        modelCoord.rotation[2] = 0.f;

        // initial scale
        modelCoord.scale[0] = 2.f/size;
        modelCoord.scale[1] = 2.f/size;
        modelCoord.scale[2] = 2.f/size;

        float currentFrame;
        ml::matrix<float> projection(4, 4);

        // render loop
        // -----------
        while(!glfwWindowShouldClose(mWindow)){
            // per-frame time logic
            // --------------------
            currentFrame = glfwGetTime();
            mDeltaTime = currentFrame - mLastFrame;
            mLastFrame = currentFrame;


            // input
            // -----
            updateInput(mWindow);

            // render
            // ------
            glClearColor(0.05f, 0.05f, 0.05f, 1.0f);
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            // don't forget to enable shader before setting uniforms
            shader.use();

            if(mOrthogonalProjection){
                //use orthogonal projection
                projection = utils::orthogonalMatrix();
            }else{
                //use perspective projection
                projection = utils::perspectiveMatrix();
            }
            // view/projection transformations
            shader.setMat4("projection", projection.getMatrix());
            ml::matrix<float> view = camera.GetViewMatrix();
            shader.setMat4("view", view.getMatrix());

            // apply rotation
            ml::matrix<float> modelMatrix(4, 4, true);
            modelMatrix = utils::rotateX(modelMatrix, modelCoord.rotation[0]);
            modelMatrix = utils::rotateY(modelMatrix, modelCoord.rotation[1]);
            modelMatrix = utils::rotateZ(modelMatrix, modelCoord.rotation[2]);

            // apply scale
            modelMatrix = utils::scale(modelMatrix, modelCoord.scale);

            // apply translation
            modelMatrix = utils::translate(modelMatrix, modelCoord.position);

            //transpose the matrix
            modelMatrix = modelMatrix.transpose();

            //pass the model matrix to the shader
            shader.setMat4("model", modelMatrix.getMatrix());

            // render the loaded model
            model.Draw(shader);


            // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
            // -------------------------------------------------------------------------------
            glfwSwapBuffers(mWindow);
            glfwPollEvents();
        }

    }

    //callback function to execute when the window is resized
    void Window::framebufferResizeCallback(GLFWwindow* window, int fbWidth, int fbHeight){
        glViewport(0, 0, fbWidth, fbHeight);
    }


    //update the user input
    void Window::updateInput(GLFWwindow *window){
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS){
            glfwSetWindowShouldClose(window, true);
        }

        bool shiftIsPressed = glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS;

        if(shiftIsPressed){
            if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS){
                camera.ProcessKeyboard(UP, mDeltaTime);
            }
            if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS){
                camera.ProcessKeyboard(DOWN, mDeltaTime);
            }
        }else{
            if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS){
                camera.ProcessKeyboard(FORWARD, mDeltaTime);
            }
            if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS){
                camera.ProcessKeyboard(BACKWARD, mDeltaTime);
            }
        }
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS){
            camera.ProcessKeyboard(LEFT, mDeltaTime);
        }
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS){
            camera.ProcessKeyboard(RIGHT, mDeltaTime);
        }

        if(mPReleased){
            if (glfwGetKey(window, GLFW_KEY_P) == GLFW_PRESS){
                mOrthogonalProjection = !mOrthogonalProjection;
            }
            mPReleased = false;
        }
        if (glfwGetKey(window, GLFW_KEY_P) == GLFW_RELEASE){
            mPReleased = true;
        }

    }

    // glfw: whenever the mouse moves, this callback is called
    // -------------------------------------------------------
    void mouseCallback(GLFWwindow* window, double xpos, double ypos)
    {
        if (firstMouse)
        {
            lastX = xpos;
            lastY = ypos;
            firstMouse = false;
        }

        float xoffset = xpos - lastX;
        float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top

        lastX = xpos;
        lastY = ypos;

        camera.ProcessMouseMovement(xoffset, yoffset);
    }

    // glfw: whenever the mouse scroll wheel scrolls, this callback is called
    // ----------------------------------------------------------------------
    void scrollCallback(GLFWwindow* window, double xoffset, double yoffset)
    {
        camera.ProcessMouseScroll(yoffset);
    }


    void Window::glfwErrorCallback(int error, const char* description) {
    std::cerr << "GLFW error code " << error << ". Description: " << description << std::endl;
    }

}
