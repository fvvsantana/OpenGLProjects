#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include <graphicslib.hpp>
#include <utils.hpp>
#include <matrixlib.hpp>
#include <shader.hpp>
#include <model.hpp>

namespace graphicslib {

    //initialize glfw stuff
    Window::Window(int windowWidth, int windowHeight){
        //listen for errors generated by glfw
        glfwSetErrorCallback(glfwErrorCallback);

        //initialize glfw
        glfwInit();

        //set some window options
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE); //make window resizable
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); //compatibility to mac os users

        mWindowWidth = windowWidth;
        mWindowHeight = windowHeight;
        mWindow = NULL;
        mCoreProgram = 0;
    }

    //destroy everything
    Window::~Window(){
        //destroy window
        if(mWindow){
            glfwDestroyWindow(mWindow);
        }
        //delete program
        if(mCoreProgram){
            glDeleteProgram(mCoreProgram);
        }
        glfwTerminate();
    }


    //create the window, load glad, load shaders
    void Window::createWindow() {
        //create window
        mWindow = glfwCreateWindow(mWindowWidth, mWindowHeight, "MODEL", NULL, NULL);

        if(mWindow == NULL) {
            std::cerr << "Failed to create GLFW window" << std::endl;
            this->~Window();
            return;
        }

        //set callback function to call when resize
        glfwSetFramebufferSizeCallback(mWindow, framebufferResizeCallback);

        //make context current
        glfwMakeContextCurrent(mWindow); //IMPORTANT!!

        //enable vsync
        glfwSwapInterval(1);

        //glad: load all OpenGL function pointers
        if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){
            std::cerr << "Failed to initialize GLAD" << std::endl;
            this->~Window();
            return;
        }

        //opengl options
        //make possible using 3d
        glEnable(GL_DEPTH_TEST);

    }


    void Window::run(char *filepath){

        // build and compile shaders
        // -------------------------
        Shader shader("src/model.vs", "src/model.fs");

        // load models
        // -----------
        Model model(filepath);

        // calculate the bounding box of the model
        model.calcBoundingBox();

        // size of the biggest dimension of the model
        float size = model.biggestDimensionSize();

        // rate on which the model will rotate and scale
        float rotation_mobility = 0.05;
        float scale_mobility = 0.001;

        // initial position
        modelCoord.position[0] = -(model.boundingBox.x.center);
        modelCoord.position[1] = -(model.boundingBox.y.center);
        modelCoord.position[2] = -(model.boundingBox.z.center);

        // initial rotation
        modelCoord.rotation[0] = 0.f;
        modelCoord.rotation[1] = 180.f;
        modelCoord.rotation[2] = 0.f;

        // initial scale
        modelCoord.scale[0] = 2.f/size;
        modelCoord.scale[1] = 2.f/size;
        modelCoord.scale[2] = 2.f/size;

        // render loop
        // -----------
        while(!glfwWindowShouldClose(mWindow)){

            // input
            // -----
            updateInput(mWindow, rotation_mobility, scale_mobility);

            // render
            // ------
            glClearColor(0.05f, 0.05f, 0.05f, 1.0f);
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            // don't forget to enable shader before setting uniforms
            shader.use();

            // render the loaded model
            ml::matrix<float> modelMatrix(4, 4, true);

            modelMatrix = utils::rotateX(modelMatrix, modelCoord.rotation[0]);
            modelMatrix = utils::rotateY(modelMatrix, modelCoord.rotation[1]);
            modelMatrix = utils::rotateZ(modelMatrix, modelCoord.rotation[2]);

            modelMatrix = utils::scale(modelMatrix, modelCoord.scale); // it's a bit too big for our scene, so scale it down

            modelMatrix = utils::translate(modelMatrix, modelCoord.position); // translate it down so it's at the center of the scene

            modelMatrix = modelMatrix.transpose();

            shader.setMat4("model", modelMatrix.getMatrix());
            model.Draw(shader);


            // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
            // -------------------------------------------------------------------------------
            glfwSwapBuffers(mWindow);
            glfwPollEvents();
        }

    }

    //callback function to execute when the window is resized
    void Window::framebufferResizeCallback(GLFWwindow* window, int fbWidth, int fbHeight){
        glViewport(0, 0, fbWidth, fbHeight);
    }

    //update the user input
    void Window::updateInput(GLFWwindow *window, float rotation_mobility, float scale_mobility){

        bool shiftIsPressed = glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) || glfwGetKey(window, GLFW_KEY_RIGHT_SHIFT);

        if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS){
            glfwSetWindowShouldClose(window, GLFW_TRUE);
        }

        if(shiftIsPressed){
            if(glfwGetKey(window, GLFW_KEY_X) == GLFW_PRESS){
                modelCoord.rotation[0] += rotation_mobility;
            }
            if(glfwGetKey(window, GLFW_KEY_Y) == GLFW_PRESS){
                modelCoord.rotation[1] += rotation_mobility;
            }
            if(glfwGetKey(window, GLFW_KEY_Z) == GLFW_PRESS){
                modelCoord.rotation[2] += rotation_mobility;
            }
        }else{
            if(glfwGetKey(window, GLFW_KEY_X) == GLFW_PRESS){
                modelCoord.rotation[0] -= rotation_mobility;
            }
            if(glfwGetKey(window, GLFW_KEY_Y) == GLFW_PRESS){
                modelCoord.rotation[1] -= rotation_mobility;
            }
            if(glfwGetKey(window, GLFW_KEY_Z) == GLFW_PRESS){
                modelCoord.rotation[2] -= rotation_mobility;
            }

        }

        if(glfwGetKey(window, GLFW_KEY_M) == GLFW_PRESS){
            modelCoord.scale[0] += scale_mobility;
            modelCoord.scale[1] += scale_mobility;
            modelCoord.scale[2] += scale_mobility;
        }

        if(glfwGetKey(window, GLFW_KEY_N) == GLFW_PRESS){
            modelCoord.scale[0] -= scale_mobility;
            modelCoord.scale[1] -= scale_mobility;
            modelCoord.scale[2] -= scale_mobility;
        }
    }



    void Window::glfwErrorCallback(int error, const char* description) {
    std::cerr << "GLFW error code " << error << ". Description: " << description << std::endl;
    }

}
