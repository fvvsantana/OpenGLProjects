#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include <graphicslib.hpp>
#include <utils.hpp>
#include <matrixlib.hpp>
#include <shader.hpp>
#include <model.hpp>
#include <camera.hpp>

#include <glm/gtc/type_ptr.hpp>


#define FILE "scene.txt"


namespace graphicslib {

    // camera
    Camera camera;
    float lastX;
    float lastY;
    float firstMouse = true;

    // lighting
    glm::vec3 lightPos(1.2f, 1.0f, 2.0f);

    //initialize glfw stuff
    Window::Window(int windowWidth, int windowHeight){
        //listen for errors generated by glfw
        glfwSetErrorCallback(glfwErrorCallback);

        //initialize glfw
        glfwInit();

        //set some window options
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE); //make window resizable
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); //compatibility to mac os users

        mWindowWidth = windowWidth;
        mWindowHeight = windowHeight;
        mWindow = NULL;
        mCoreProgram = 0;


        lastX = windowWidth/2.0f;
        lastY = windowHeight/2.0f;

        mPhong = true;
        mPReleased = true;

        // timing
        mDeltaTime = 0.0f;
        mLastFrame = 0.0f;
    }

    //destroy everything
    Window::~Window(){
        //destroy window
        if(mWindow){
            glfwDestroyWindow(mWindow);
        }
        //delete program
        if(mCoreProgram){
            glDeleteProgram(mCoreProgram);
        }
        glfwTerminate();
    }


    //create the window, load glad, load shaders
    void Window::createWindow() {
        //create window
        mWindow = glfwCreateWindow(mWindowWidth, mWindowHeight, "Camera View", NULL, NULL);

        if(mWindow == NULL) {
            std::cerr << "Failed to create GLFW window" << std::endl;
            this->~Window();
            return;
        }

        //make context current
        glfwMakeContextCurrent(mWindow); //IMPORTANT!!

        //set callback function to call when resize
        glfwSetFramebufferSizeCallback(mWindow, framebufferResizeCallback);
        glfwSetCursorPosCallback(mWindow, mouseCallback);

        // tell GLFW to capture our mouse
        glfwSetInputMode(mWindow, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

        //enable vsync
        glfwSwapInterval(1);

        //glad: load all OpenGL function pointers
        if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){
            std::cerr << "Failed to initialize GLAD" << std::endl;
            this->~Window();
            return;
        }

        //opengl options
        //make possible using 3d
        glEnable(GL_DEPTH_TEST);

        //allow us to change the size of a point
        glEnable(GL_PROGRAM_POINT_SIZE);

    }


    void Window::run(){

        Shader phongColorShader("src/multipleLightsPhongColor.vs", "src/multipleLightsPhongColor.fs");
        Shader gouraudColorShader("src/multipleLightsGouraudColor.vs", "src/multipleLightsGouraudColor.fs");

        Shader phongTexShader("src/multipleLightsPhongTex.vs", "src/multipleLightsPhongTex.fs");
        Shader gouraudTexShader("src/multipleLightsGouraudTex.vs", "src/multipleLightsGouraudTex.fs");

        //------------------//
        //READ THE SCENE.TXT//
        //------------------//

        std::ifstream sceneFile(FILE);
        //check if an error has ocurred while opening the file
        if(!sceneFile){
            std::cerr << "*** Error while opening file " << FILE << " ***" << std::endl;
            exit(EXIT_FAILURE);
        }
        std::string line;
        

        // structures that will be used to read objects and display them on the screen
        // --------------------------------------------------------------------------------------------
        int i = 0;
        
        //delta is the distance between the origin of the coordinate system and the center of the i model
        std::vector<float> delta;
        delta.push_back(0);

        // -------------------------------------------------------------------------------------------


        //initialize the number of lights
        lightingInformation.numberOfPointLights = 0;
        //read a line of the file
        while(std::getline(sceneFile, line)){
            //treat the case of having \n in the end of the file
            if(line.compare("") == 0){
                continue;
            }

            // first word of the line
            std::string firstWord;

            //read the first word of the line
            std::istringstream lineStream(line);
            lineStream >> firstWord;

            //if it's adding a light in the scene
            if(firstWord == "light"){
                //get the point light to alter
                int index = lightingInformation.numberOfPointLights;
                PointLight* currentPointLight = &lightingInformation.pointLights[index];

                char auxString[20];
                //read and store the information in the point light
                sscanf(lineStream.str().c_str(), "%s  %f %f %f  %f %f %f  %f %f %f",
                       auxString,
                       &(currentPointLight->position[0]),
                       &(currentPointLight->position[1]),
                       &(currentPointLight->position[2]),
                       &(currentPointLight->ambient[0]),
                       &(currentPointLight->ambient[1]),
                       &(currentPointLight->ambient[2]),
                       &(currentPointLight->linear),
                       &(currentPointLight->constant),
                       &(currentPointLight->quadratic));
                currentPointLight->diffuse = currentPointLight->ambient;
                currentPointLight->specular = currentPointLight->ambient;


                //also alter the point light for buffer
                PointLightForBuffer* currentPointLightForBuffer = &lightingInformation.bufferOfPointLights[index];
                currentPointLightForBuffer->position = currentPointLight->position;
                currentPointLightForBuffer->color = currentPointLight->ambient;

                //increment the number of point lights
                lightingInformation.numberOfPointLights++;
            }

            // if it's defining a camera
            else if(firstWord == "camera"){
                glm::vec3 position, up, lookAt;
                // read information about the camera (position, lookAt point and view up vector)
                lineStream >> position.x >> position.y >> position.z
                           >> lookAt.x >> lookAt.y >> lookAt.z
                           >> up.x >> up.y >> up.z;
                camera = Camera(position, up, lookAt);
            }

            // if it's defining an object
            else if(firstWord == "object"){
                std::string path;
                glm::vec3 finalPos;
                lineStream >> path >> finalPos.x >> finalPos.y >> finalPos.z;

                //create an ModelInformation instance
                ModelInformation currentModelInfo;

                //create a new model
                currentModelInfo.model = new Model(path);
                //add a reference to it just to ease the coding
                Model &model = *(currentModelInfo.model);


                //check if the model has textures
                if(model.getNumberOfTexturesLoaded()){
                    //set the shaders with textures
                    currentModelInfo.phongShader = &phongTexShader;
                    currentModelInfo.gouraudShader = &gouraudTexShader;
                }else{
                    //set the shaders with color
                    currentModelInfo.phongShader = &phongColorShader;
                    currentModelInfo.gouraudShader = &gouraudColorShader;
                }


                //set model coordinates

                // calculate the bounding box of the model
                model.calcBoundingBox();

                // size of the biggest dimension of the model
                float size = model.biggestDimensionSize();

                // initial rotation
                currentModelInfo.rotation[0] = 0.f;
                currentModelInfo.rotation[1] = 0.f;
                currentModelInfo.rotation[2] = 0.f;

                // initial scale
                currentModelInfo.scale[0] = 2.f/size;
                currentModelInfo.scale[1] = 2.f/size;
                currentModelInfo.scale[2] = 2.f/size;

                // translate object to position "finalPos"
                currentModelInfo.position[0] = finalPos.x - model.boundingBox.x.center;
                currentModelInfo.position[1] = finalPos.y - model.boundingBox.y.center;
                currentModelInfo.position[2] = finalPos.z - model.boundingBox.z.center;

              
                i++;

                //finally append the current information to the vector
                mModelInformationVector.push_back(currentModelInfo);


            }

        }
        sceneFile.close();




        //-------------//
        //SETUP SHADERS//
        //-------------//

        //load the point lights VAO (buffer already filled)
        unsigned int pointLightsVAO = loadPointLightsVAO();

#ifdef SHOW_CUBE
        //load the cube
        unsigned int cubeVAO = loadCubeVAO();
#endif

        float currentFrame;
        ml::matrix<float> projection(4, 4);
        ml::matrix<float> view(4, 4);
        ml::matrix<float> modelMatrix(4, 4, true);


        Shader phongShader("src/multipleLightsPhong.vs", "src/multipleLightsPhong.fs");
        //set phong shader material properties
        phongShader.use();
        phongShader.setInt("material.diffuse", 0);
        phongShader.setInt("material.specular", 1);
        phongShader.setFloat("material.shininess", 32.0f);

        //send the number of point lights
        phongShader.setInt("numberOfPointLights", lightingInformation.numberOfPointLights);


        Shader gouraudShader("src/multipleLightsGouraud.vs", "src/multipleLightsGouraud.fs");
        //set gouraud shader material properties
        gouraudShader.use();
        gouraudShader.setInt("material.diffuse", 0);
        gouraudShader.setInt("material.specular", 1);
        gouraudShader.setFloat("material.shininess", 32.0f);

        //send the number of point lights
        gouraudShader.setInt("numberOfPointLights", lightingInformation.numberOfPointLights);
        //send the color of the cube
        gouraudShader.setVec3("objectColor", glm::vec3(1.0, 0.5, 0.31));


        //setup the multiple light model using textures
        phongTexShader.use();
        phongTexShader.setFloat("shininess", 32.0f);
        //send the number of point lights
        phongTexShader.setInt("numberOfPointLights", lightingInformation.numberOfPointLights);


        //setup the multiple light model using textures
        gouraudTexShader.use();
        gouraudTexShader.setFloat("shininess", 32.0f);
        //send the number of point lights
        gouraudTexShader.setInt("numberOfPointLights", lightingInformation.numberOfPointLights);

        //setup the multiple light model using textures
        phongColorShader.use();
        phongColorShader.setFloat("shininess", 32.0f);
        //send the number of point lights
        phongColorShader.setInt("numberOfPointLights", lightingInformation.numberOfPointLights);


        //setup the multiple light model using textures
        gouraudColorShader.use();
        gouraudColorShader.setFloat("shininess", 32.0f);
        //send the number of point lights
        gouraudColorShader.setInt("numberOfPointLights", lightingInformation.numberOfPointLights);

        Shader lampShader("src/lamp.vs", "src/lamp.fs");




        //-----------//
        //RENDER LOOP//
        //-----------//

        // render loop
        while(!glfwWindowShouldClose(mWindow)){
            // per-frame time logic
            currentFrame = glfwGetTime();
            mDeltaTime = currentFrame - mLastFrame;
            mLastFrame = currentFrame;

            // input
            updateInput(mWindow);

            // render
            glClearColor(0.05f, 0.05f, 0.05f, 1.0f);
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);



            if(mPhong){
                //enable shader
                phongTexShader.use();
                //use perspective projection
                projection = utils::perspectiveMatrix(0.f, 1.f, 0.f, 1.f, 5.f, -5.f);
                // view/projection transformations
                phongTexShader.setMat4("projection", projection.getMatrix());
                view = camera.GetViewMatrix();
                phongTexShader.setMat4("view", view.getMatrix());

                //enable shader
                phongColorShader.use();
                //use perspective projection
                projection = utils::perspectiveMatrix(0.f, 1.f, 0.f, 1.f, 5.f, -5.f);
                // view/projection transformations
                phongColorShader.setMat4("projection", projection.getMatrix());
                view = camera.GetViewMatrix();
                phongColorShader.setMat4("view", view.getMatrix());
            }else{
                //enable shader
                gouraudTexShader.use();
                //use perspective projection
                projection = utils::perspectiveMatrix(0.f, 1.f, 0.f, 1.f, 5.f, -5.f);
                // view/projection transformations
                gouraudTexShader.setMat4("projection", projection.getMatrix());
                view = camera.GetViewMatrix();
                gouraudTexShader.setMat4("view", view.getMatrix());

                //enable shader
                gouraudColorShader.use();
                //use perspective projection
                projection = utils::perspectiveMatrix(0.f, 1.f, 0.f, 1.f, 5.f, -5.f);
                // view/projection transformations
                gouraudColorShader.setMat4("projection", projection.getMatrix());
                view = camera.GetViewMatrix();
                gouraudColorShader.setMat4("view", view.getMatrix());

            }


            i = 0;
            // render the loaded models
            for(auto modelInfo : mModelInformationVector){

                Shader* currentShader;

                if(mPhong){
                    currentShader = modelInfo.phongShader;
                }else{
                    currentShader = modelInfo.gouraudShader;
                }

                currentShader->use();

                //TODO put this thing in the if out of the for
                currentShader->setVec3("viewPos", camera.Position);

                //send the point lights information to the shader for each point light
                for(int i = 0; i < lightingInformation.numberOfPointLights; i++){
                //get the point light
                PointLight* currentPointLight = &lightingInformation.pointLights[i];
                //set the parameters of the shader
                currentShader->setVec3(std::string("pointLights[") + std::to_string(i) +
                    std::string("].position"), currentPointLight->position);
                currentShader->setFloat(std::string("pointLights[") + std::to_string(i) +
                    std::string("].constant"), currentPointLight->constant);
                currentShader->setFloat(std::string("pointLights[") + std::to_string(i) +
                    std::string("].linear"), currentPointLight->linear);
                currentShader->setFloat(std::string("pointLights[") + std::to_string(i) +
                    std::string("].quadratic"), currentPointLight->quadratic);
                currentShader->setVec3(std::string("pointLights[") + std::to_string(i) +
                    std::string("].ambient"), currentPointLight->ambient);
                currentShader->setVec3(std::string("pointLights[") + std::to_string(i) +
                    std::string("].diffuse"), currentPointLight->diffuse);
                currentShader->setVec3(std::string("pointLights[") + std::to_string(i) +
                    std::string("].specular"), currentPointLight->specular);
                }

                //translate the current model to the side of the previous model
                ml::matrix<float> modelMatrix(4, 4, true);
                //tmp is the array used to translate the model using its assigned delta value
                float tmp[3] = {delta[i], 0, 0};
                modelMatrix = utils::translate(modelMatrix, tmp);

                // apply rotation
                modelMatrix = utils::rotateX(modelMatrix, modelInfo.rotation[0]);
                modelMatrix = utils::rotateY(modelMatrix, modelInfo.rotation[1]);
                modelMatrix = utils::rotateZ(modelMatrix, modelInfo.rotation[2]);

                // apply scale
                modelMatrix = utils::scale(modelMatrix, modelInfo.scale);

                // apply translation to the origin
                modelMatrix = utils::translate(modelMatrix, modelInfo.position);


                //transpose the matrix
                modelMatrix = modelMatrix.transpose();

                //pass the model matrix to the shader
                currentShader->setMat4("model", modelMatrix.getMatrix());
                modelInfo.model->Draw(*currentShader);

                i++;
            }


#ifdef SHOW_CUBE

            //use the phong shader
            if(mPhong){

                //---------//
                //DRAW CUBE//
                //---------//

                // be sure to activate shader when setting uniforms/drawing objects
                phongShader.use();
                phongShader.setVec3("viewPos", camera.Position);

                //send the point lights information to the shader for each point light
                for(int i = 0; i < lightingInformation.numberOfPointLights; i++){
                    //get the point light
                    PointLight* currentPointLight = &lightingInformation.pointLights[i];
                    //set the parameters of the shader
                    phongShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].position"), currentPointLight->position);
                    phongShader.setFloat(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].constant"), currentPointLight->constant);
                    phongShader.setFloat(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].linear"), currentPointLight->linear);
                    phongShader.setFloat(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].quadratic"), currentPointLight->quadratic);
                    phongShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].ambient"), currentPointLight->ambient);
                    phongShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].diffuse"), currentPointLight->diffuse);
                    phongShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].specular"), currentPointLight->specular);
                }

                //set tranformation matrices
                modelMatrix = modelMatrix.transpose();
                phongShader.setMat4("model", modelMatrix.getMatrix());
                view = camera.GetViewMatrix();
                phongShader.setMat4("view", view.getMatrix());
                projection = utils::perspectiveMatrix(0.f, 1.f, 0.f, 1.f, 5.f, -5.f);
                phongShader.setMat4("projection", projection.getMatrix());

                // render the cube
                glBindVertexArray(cubeVAO);
                glDrawArrays(GL_TRIANGLES, 0, 36);


            //use the gouraud shader
            }else{

                //---------//
                //DRAW CUBE//
                //---------//

                // be sure to activate shader when setting uniforms/drawing objects
                gouraudShader.use();
                gouraudShader.setVec3("viewPos", camera.Position);

                //send the point lights information to the shader for each point light
                for(int i = 0; i < lightingInformation.numberOfPointLights; i++){
                    //get the point light
                    PointLight* currentPointLight = &lightingInformation.pointLights[i];
                    //set the parameters of the shader
                    gouraudShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].position"), currentPointLight->position);
                    gouraudShader.setFloat(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].constant"), currentPointLight->constant);
                    gouraudShader.setFloat(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].linear"), currentPointLight->linear);
                    gouraudShader.setFloat(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].quadratic"), currentPointLight->quadratic);
                    gouraudShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].ambient"), currentPointLight->ambient);
                    gouraudShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].diffuse"), currentPointLight->diffuse);
                    gouraudShader.setVec3(std::string("pointLights[") + std::to_string(i) +
                                        std::string("].specular"), currentPointLight->specular);
                }

                // be sure to activate shader when setting uniforms/drawing objects
                gouraudShader.use();
                gouraudShader.setVec3("objectColor", 1.0f, 0.5f, 0.31f);

                // view/projection transformations
                modelMatrix = modelMatrix.transpose();
                gouraudShader.setMat4("model", modelMatrix.getMatrix());
                view = camera.GetViewMatrix();
                gouraudShader.setMat4("view", view.getMatrix());
                projection = utils::perspectiveMatrix(0.f, 1.f, 0.f, 1.f, 5.f, -5.f);
                gouraudShader.setMat4("projection", projection.getMatrix());

                // render the cube
                glBindVertexArray(cubeVAO);
                glDrawArrays(GL_TRIANGLES, 0, 36);
            }



#endif

            //-----------------//
            //DRAW POINT LIGHTS//
            //-----------------//


            lampShader.use();
            // view/projection transformations
            lampShader.setMat4("projection", projection.getMatrix());
            lampShader.setMat4("view", view.getMatrix());
            lampShader.setMat4("model", modelMatrix.getMatrix());

            //draw the pointLight
            glBindVertexArray(pointLightsVAO);
            glDrawArrays(GL_POINTS, 0, lightingInformation.numberOfPointLights);




            // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
            glfwSwapBuffers(mWindow);
            glfwPollEvents();
        }

        //delete the allocated models
        for(auto modelInfo: mModelInformationVector){
            if(modelInfo.model){
                delete modelInfo.model;
            }
        }

    }

#ifdef SHOW_CUBE
    // set up vertex data (and buffer(s)) and configure vertex attributes from the cube
    unsigned int Window::loadCubeVAO(){

        // ------------------------------------------------------------------
        // configure the cube's VAO (and VBO)
        unsigned int VBO, cubeVAO;
        glGenVertexArrays(1, &cubeVAO);
        glGenBuffers(1, &VBO);

        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), cubeVertices, GL_STATIC_DRAW);

        glBindVertexArray(cubeVAO);

        // position attribute
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        // normal attribute
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);

        return cubeVAO;
    }
#endif

    //gen and setup a VAO to the point lights and fill it's buffer
    unsigned int Window::loadPointLightsVAO(){

        //generate the VAO
        unsigned int pointLightsVBO, pointLightsVAO;
        glGenVertexArrays(1, &pointLightsVAO);

        //fill the buffer with the light points
        glGenBuffers(1, &pointLightsVBO);
        glBindBuffer(GL_ARRAY_BUFFER, pointLightsVBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(PointLightForBuffer) * lightingInformation.numberOfPointLights,
                     lightingInformation.bufferOfPointLights, GL_STATIC_DRAW);

        //setup the VAO attributes
        glBindVertexArray(pointLightsVAO);
        // position attribute
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(PointLightForBuffer), (void*)0);
        glEnableVertexAttribArray(0);
        // color attribute
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(PointLightForBuffer), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);

        return pointLightsVAO;
    }

    //callback function to execute when the window is resized
    void Window::framebufferResizeCallback(GLFWwindow* window, int fbWidth, int fbHeight){
        glViewport(0, 0, fbWidth, fbHeight);
    }


    //update the user input
    void Window::updateInput(GLFWwindow *window){
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS){
            glfwSetWindowShouldClose(window, true);
        }

        bool shiftIsPressed = glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS;

        if(shiftIsPressed){
            if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS){
                camera.ProcessKeyboard(UP, mDeltaTime);
            }
            if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS){
                camera.ProcessKeyboard(DOWN, mDeltaTime);
            }
        }else{
            if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS){
                camera.ProcessKeyboard(FORWARD, mDeltaTime);
            }
            if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS){
                camera.ProcessKeyboard(BACKWARD, mDeltaTime);
            }
        }
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS){
            camera.ProcessKeyboard(LEFT, mDeltaTime);
        }
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS){
            camera.ProcessKeyboard(RIGHT, mDeltaTime);
        }

        if(mPReleased){
            if (glfwGetKey(window, GLFW_KEY_L) == GLFW_PRESS){
                mPhong = !mPhong;
            }
            mPReleased = false;
        }
        if (glfwGetKey(window, GLFW_KEY_L) == GLFW_RELEASE){
            mPReleased = true;
        }

    }

    // glfw: whenever the mouse moves, this callback is called
    void mouseCallback(GLFWwindow* window, double xpos, double ypos)
    {
        if (firstMouse)
        {
            lastX = xpos;
            lastY = ypos;
            firstMouse = false;
        }

        float xoffset = xpos - lastX;
        // yoffset reversed since y-coordinates go from bottom to top
        float yoffset = lastY - ypos; 

        lastX = xpos;
        lastY = ypos;

        camera.ProcessMouseMovement(xoffset, yoffset);
    }

    void Window::glfwErrorCallback(int error, const char* description) {
        std::cerr << "GLFW error code " << error << ". Description: " << description << std::endl;
    }

}
